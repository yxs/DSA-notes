[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
return the k most frequent elements


## heap

time complexity `O(nlogk)`, n is len(nums), heap size is `k`, per heap operation `O(logk)`

space complexity `O(n)`, more accurate is `O(n)` hashmap + `O(k)` heap size

1. Python defaults to a min heap, so there is a negative sign.
2. Swap k, v to return the result


```python
from typing import List
import heapq
from collections import Counter


class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        res = []
        cnt = Counter(nums)  # {num, freq}
        max_heap = [(-v, k) for k, v in cnt.items()]
        heapq.heapify(max_heap)
        for _ in range(max_heap):
            res.append(heapq.heappop(max_heap)[1])
        return res
```

## bucket sort

tc `O(n)`, sc `O(n)`

```python
from itertools import chain
from typing import List
from collections import Counter


def topKFrequent(nums: List[int], k: int) -> List[int]:
    bucket = [[] for _ in range(len(nums) + 1)]
    Count = Counter(nums).items()
    for num, freq in Count:
        bucket[freq].append(num)
    flat_list = list(chain(*bucket))  # * means unpacks
    return flat_list[::-1][:k]
```

## Ref.

https://docs.python.org/3/library/itertools.html#itertools.chain

> Used for treating consecutive sequences as a single sequence
> chain('ABC', 'DEF') --> A B C D E F

https://github.com/neetcode-gh/leetcode/blob/main/347-Top-k-frequent-elements.py

https://leetcode.com/problems/top-k-frequent-elements/discuss/740374/Python-5-lines-O(n)-buckets-solution-explained