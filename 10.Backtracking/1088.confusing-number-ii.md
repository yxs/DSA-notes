### [1088. Confusing Number II](https://leetcode.com/problems/confusing-number-ii/) Premium

[1088. 易混淆数 II](https://leetcode-cn.com/problems/confusing-number-ii/) 会员

Q: A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid. return the number of confusing numbers in [1, n]

A: ?

```python
class Solution:
    def confusingNumberII(self, N: int) -> int:
        if N < 6:
            return 0
        elif N < 9:
            return 1
        elif N == 9:
            return 2

        N = list(map(int, list(str(N))))
        n = len(N)
        res = 5 ** (n - 1) - 1  # 计算数位小于n且由reflex中的数作数码的个数
        less = [0, 1, 2, 2, 2, 2, 2, 3, 3, 4]  # less[i]表示小于i且属于reflex的数的个数
        reflex = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}
        # 根据N每一位的数码，计算数位等于n且由reflex中的数作数码的个数
        res += (less[N[0]] - 1) * 5 ** (n - 1)
        if N[0] in reflex:
            for i in range(1, n):
                res += less[N[i]] * 5 ** (n - i - 1)
                if N[i] not in reflex:
                    break
            else:
                res += 1

        # 计算数位小于n且由reflex中的数作数码的非混淆数
        for i in range(1, n):
            if i == 1:
                res -= 2
            elif i & 1:
                res -= 12 * 5 ** (i - 3 >> 1)
            else:
                res -= 4 * 5 ** (i - 2 >> 1)

        # 根据n的奇偶性分类讨论
        if n & 1:
            res -= 3 * (less[N[0]] - 1) * 5 ** (n - 3 >> 1)
            if N[0] not in reflex:
                return res

            for i in range(1, n >> 1):
                res -= 3 * less[N[i]] * 5 ** ((n - 3 >> 1) - i)
                if N[i] not in reflex:
                    return res

            a = N[n >> 1]
            if not a:
                pass
            elif a == 1:
                res -= 1
            elif a < 8:
                res -= 2
                return res
            elif a == 8:
                res -= 2
            elif a == 9:
                res -= 3
                return res

            for i in range((n >> 1) + 1, n):
                a, b = N[-i - 1], N[i]
                if b > reflex[a]:
                    return res - 1
                if b < reflex[a]:
                    return res
            return res - 1
        else:
            res -= (less[N[0]] - 1) * 5 ** (n - 2 >> 1)
            if N[0] not in reflex:
                return res

            for i in range(1, n >> 1):
                res -= less[N[i]] * 5 ** ((n >> 1) - i - 1)
                if N[i] not in reflex:
                    return res

            for i in range((n >> 1), n):
                a, b = N[-i - 1], N[i]
                if b > reflex[a]:
                    return res - 1
                if b < reflex[a]:
                    return res
            return res - 1

```